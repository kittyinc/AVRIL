{\rtf1\ansi \deff51\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier{\*\falt Courier New};}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica{\*\falt Arial};}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\froman\fcharset0\fprq2 New York;}{\f13\fswiss\fcharset0\fprq2 Geneva;}{\f14\froman\fcharset0\fprq2 CG Times;}{\f15\fswiss\fcharset0\fprq2 Univers;}
{\f16\fswiss\fcharset0\fprq2 Univers Condensed;}{\f17\fswiss\fcharset0\fprq2 Antique Olive;}{\f18\fswiss\fcharset0\fprq2 Albertus Medium;}{\f19\fswiss\fcharset0\fprq2 Albertus Extra Bold;}{\f20\fmodern\fcharset0\fprq1 Letter Gothic;}
{\f21\fnil\fcharset2\fprq2 Wingdings;}{\f22\fnil\fcharset2\fprq2 Marlett;}{\f23\fswiss\fcharset0\fprq2 Aardvark;}{\f24\fswiss\fcharset0\fprq2 Brooklyn;}{\f25\fswiss\fcharset0\fprq2 Carleton;}{\f26\fswiss\fcharset0\fprq2 DawnCastle;}
{\f27\fswiss\fcharset0\fprq2 Erie;}{\f28\fnil\fcharset0\fprq2 Lansbury;}{\f29\fswiss\fcharset0\fprq2 Lincoln;}{\f30\fswiss\fcharset0\fprq2 Merlin;}{\f31\fscript\fcharset0\fprq2 OzHandicraft BT;}{\f32\fswiss\fcharset0\fprq2 Verdana;}
{\f33\fscript\fcharset0\fprq2 Comic Sans MS;}{\f34\fswiss\fcharset0\fprq2 Copperplate Gothic Bold;}{\f35\fswiss\fcharset0\fprq2 Copperplate Gothic Light;}{\f36\fswiss\fcharset0\fprq2 Tahoma;}{\f37\fswiss\fcharset0\fprq2 Arial Narrow;}
{\f38\fswiss\fcharset0\fprq2 Haettenschweiler;}{\f39\froman\fcharset0\fprq2 Garamond;}{\f40\fmodern\fcharset2\fprq1 MS LineDraw;}{\f41\fswiss\fcharset0\fprq2 Arial Black;}{\f42\fswiss\fcharset0\fprq2 Impact;}{\f43\froman\fcharset2\fprq2 Webdings;}
{\f44\fnil\fcharset2\fprq2 MS Outlook;}{\f45\fmodern\fcharset0\fprq1 Lucida Console;}{\f46\froman\fcharset0\fprq2 Georgia;}{\f47\fswiss\fcharset0\fprq2 Trebuchet MS;}{\f48\fmodern\fcharset0\fprq1 Andale Mono;}{\f49\fmodern\fcharset255\fprq2 Modern;}
{\f50\fswiss\fcharset0\fprq1 MS Dialog;}{\f51\froman\fcharset0\fprq0 Times Roman{\*\falt Times New Roman};}{\f52\froman\fcharset0\fprq0 Times Roman Bold{\*\falt Times New Roman};}{\f53\froman\fcharset0\fprq0 Times Roman Italic{\*\falt Times New Roman};}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar \f51 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar \f51 \sbasedon0\snext15 
endnote text;}{\*\cs16 \additive\super \sbasedon10 endnote reference;}{\s17\nowidctlpar \f51 \sbasedon0\snext17 footnote text;}{\*\cs18 \additive\super \sbasedon10 footnote reference;}{\s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 \snext19 Section;}{\*
\cs20 \additive\f11\fs16\lang1033 \sbasedon10 Listing;}{\*\cs21 \additive\b\f51\fs24\lang1033 \sbasedon10 Heading;}{\*\cs22 \additive\sbasedon10 Document 8;}{\*\cs23 \additive\b\i\fs24 \sbasedon10 Document 4;}{\*\cs24 \additive\sbasedon10 Document 6;}{\*
\cs25 \additive\sbasedon10 Document 5;}{\*\cs26 \additive\f51\fs24\lang1033 \sbasedon10 Document 2;}{\*\cs27 \additive\sbasedon10 Document 7;}{\*\cs28 \additive\sbasedon10 Bibliogrphy;}{\*\cs29 \additive\sbasedon10 Right Par 1;}{\*\cs30 \additive
\sbasedon10 Right Par 2;}{\*\cs31 \additive\f51\fs24\lang1033 \sbasedon10 Document 3;}{\*\cs32 \additive\sbasedon10 Right Par 3;}{\*\cs33 \additive\sbasedon10 Right Par 4;}{\*\cs34 \additive\sbasedon10 Right Par 5;}{\*\cs35 \additive\sbasedon10 
Right Par 6;}{\*\cs36 \additive\sbasedon10 Right Par 7;}{\*\cs37 \additive\sbasedon10 Right Par 8;}{\s38\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 \snext38 Document 1;}{\*\cs39 \additive\f51\fs24\lang1033 \sbasedon10 Tech Init;}{\*\cs40 \additive
\sbasedon10 Technical 5;}{\*\cs41 \additive\sbasedon10 Technical 6;}{\*\cs42 \additive\f51\fs24\lang1033 \sbasedon10 Technical 2;}{\*\cs43 \additive\f51\fs24\lang1033 \sbasedon10 Technical 3;}{\*\cs44 \additive\sbasedon10 Technical 4;}{\*\cs45 \additive
\f51\fs24\lang1033 \sbasedon10 Technical 1;}{\*\cs46 \additive\sbasedon10 Technical 7;}{\*\cs47 \additive\sbasedon10 Technical 8;}{\*\cs48 \additive\sbasedon10 Doc Init;}{\s49\fi-720\li720\ri720\sb480\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 
\sbasedon0\snext0 toc 1;}{\s50\fi-720\li1440\ri720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 \sbasedon0\snext0 toc 2;}{\s51\fi-720\li2160\ri720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 \sbasedon0\snext0 toc 3;}{
\s52\fi-720\li2880\ri720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 \sbasedon0\snext0 toc 4;}{\s53\fi-720\li3600\ri720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 \sbasedon0\snext0 toc 5;}{\s54\fi-720\li720\nowidctlpar\tqr\tx9360\hyphpar0 \f51 
\sbasedon0\snext0 toc 6;}{\s55\fi-720\li720\nowidctlpar\hyphpar0 \f51 \sbasedon0\snext0 toc 7;}{\s56\fi-720\li720\nowidctlpar\tqr\tx9360\hyphpar0 \f51 \sbasedon0\snext0 toc 8;}{\s57\fi-720\li720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 
\sbasedon0\snext0 toc 9;}{\s58\fi-1440\li1440\ri720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 \sbasedon0\snext0 index 1;}{\s59\fi-720\li1440\ri720\nowidctlpar\tqr\tldot\tx9360\hyphpar0 \f51 \sbasedon0\snext0 index 2;}{
\s60\nowidctlpar\tqr\tx9360\hyphpar0 \f51 \sbasedon0\snext0 toa heading;}{\s61\nowidctlpar \f51 \sbasedon0\snext0 caption;}{\*\cs62 \additive _Equation Caption;}{\s63\nowidctlpar\tqc\tx4320\tqr\tx8640 \f51 \sbasedon0\snext63 footer;}}{\info
{\author Martin Giguere}{\operator Martin Giguere}{\creatim\yr1999\mo3\dy2\hr20\min24}{\revtim\yr1999\mo3\dy2\hr20\min25}{\version3}{\edmins1}{\nofpages23}{\nofwords8254}{\nofchars47051}{\*\company  }{\vern57431}}\margl1440\margr1440 
\widowctrl\ftnbj\aenddoc\hyphhotz950\aftnnar\notabind\wraptrsp\nocolbal\sprslnsp\hyphcaps0 \fet0{\*\ftnsep \pard\plain \nowidctlpar \f51 \chftnsep 
\par }{\*\aftnsep \pard\plain \sl-20\slmult0\widctlpar \f51 
\par }{\*\aftnsepc \pard\plain \nowidctlpar \f51  
\par }{\*\aftncn \pard\plain \nowidctlpar \f51  
\par }\sectd \pgnrestart\linex0\headery1440\footery1440\colsx709 {\footer \pard\plain \sb140\sl-100\slmult0\nowidctlpar \f51 {\fs10 
\par }\pard \qj\nowidctlpar\tqc\tx4680\hyphpar0 {\expnd0\expndtw-3\lang2057 \tab AVRIL Tutorial
\par }\pard \nowidctlpar {\lang1024 {\*\do\dobxpage\dobypara\dodhgt12289\dptxbx\dptxbxmar0{\dptxbxtext \pard\plain \nowidctlpar\tqc\tx4680\tqr\tx9360 \f51 \tab \tab {\field{\*\fldinst {\expnd0\expndtw-3\lang2057 page \\* arabic}}{\fldrslt {
\expnd0\expndtw-3\lang1024 1}}}{\expnd0\expndtw-3\lang2057 
\par }}\dpx1440\dpy240\dpxsize9360\dpysize240\dplinehollow\dplinecor0\dplinecog0\dplinecob0\dplinew0\dpfillfgcr0\dpfillfgcg0\dpfillfgcb0\dpfillbgcr0\dpfillbgcg0\dpfillbgcb0\dpfillpat0}}
\par }{\*\pnseclvl1\pnucrm\pnstart1 {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1 {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1 {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1 {\pntxta .}}{\*\pnseclvl5\pndec\pnstart1 {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1 
{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1 {\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1 {\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \nowidctlpar\hyphpar0 \f51 {\field{\*\fldinst {\f4\lang2057 
PRIVATE }{\f4\fs20\lang2057 {\*\datafield 0c0070686f656e697800010000ffffff}}}{\fldrslt }}{\f4\lang2057 
\par 
\par 
\par }\pard \qc\nowidctlpar\hyphpar0 {\f4\fs36\lang2057 Using AVRIL -- A Tutorial}{\f4\lang2057 
\par }{\f4\fs29\lang2057 Version 2.0
\par March 28, 1995
\par 
\par Bernie Roehl
\par 
\par }{\f4\lang2057 
\par }\pard \nowidctlpar\hyphpar0 {\f4\lang2057 
\par Note: This is the AVRIL tutorial.  The detailed technical reference is a separate document.
\par 
\par }{\cs21\b\f4\lang2057 What is AVRIL?}{\cs21\f4\lang2057 
\par }{\f4\lang2057 
\par \tab 
AVRIL is A Virtual Reality Interface Library, a software package that allows you to create and interact with virtual worlds.  It consists of a fast polygon-based rendering engine and a set of support routines that make virtual world creation a reasonably 
straightforward process.
\par 
\par \tab AVRIL is designed to be fast, portable and easy to use.  It's written entirely in ANSI C; the PC version also has a few short assembly-language routines to handle some of the fixed point math.  The API (Applications Programming In
terface) is simple and well-documented, which should make applications easy to develop.
\par 
\par \tab 
Most important, AVRIL is free for non-commercial use.  The problem with most current VR libraries is that they're very, very expensive; many of them cost more than the computers they run on!  AVRIL is intended to give everyone with an interest in VR an o
pportunity to develop some simple applications without having to invest huge sums of money.
\par 
\par }{\cs21\b\f4\lang2057 What does "free for non-commercial use" mean?}{\cs21\f4\lang2057 
\par }{\f4\lang2057 
\par \tab It means that if you're only writing programs for your own use, or to give away free to others, you can use AVRIL without paying anything.
\par }\pard \keep\keepn\nowidctlpar\hyphpar0 {\f4\lang2057 
\par }{\cs21\b\f4\lang2057 Who developed AVRIL?}{\cs21\f4\lang2057 
\par }{\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab 
AVRIL was developed by Bernie Roehl, between November of 1993 and April of 1995.  It's designed to be somewhat backward-compatible with an earlier rendering engine called REND386 that was developed by Bernie Roehl and Dave Stampe.
\par }\pard \keep\keepn\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }{\cs21\b\f4\lang2057 So what makes AVRIL different from REND386?}{\cs21\f4\lang2057 
\par }{\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab From the beginning, we knew that REND386 would never run on anything but computers in the 386 fami
ly; that's why we called it "REND386" in the first place.  REND386 was fast, but it achieved its speed at the price of portability; large parts of the code were hand-translated to 386 assembly language.  This obviously reduced the portability of the softw
are, as well as making it more difficult to maintain.
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab AVRIL, by contrast, is written entirely in C.  It's fast because the algorithms are well-chosen and carefully written.  While it's not as fast overall as REND386, there are actually some situations whe
re it's faster; once it's been optimized a bit, the speed should be comparable.  Since it's written in C, AVRIL is also much easier to maintain than REND386 was.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Using AVRIL}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par \tab AVRIL is very easy to use.  Rather than spend a lot of time discussing the details of how it works, let's start by creating a simple AVRIL program:
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 /* EXAMPLE1 \_\_ a cube */
\par 
\par /* Written by Bernie Roehl, April 1994 */
\par 
\par #include "avril.h"
\par 
\par void main()
\par \tab \{
\par \tab vrl_Object *cube;
\par \tab vrl_Light *light;
\par \tab vrl_Camera *camera;
\par 
\par \tab vrl_SystemStartup();
\par 
\par \tab cube = vrl_ObjectCreate(vrl_PrimitiveBox(100, 100, 100, NULL));
\par \tab vrl_ObjectRotY(cube, float2angle(45));
\par 
\par \tab light = vrl_LightCreate();
\par \tab vrl_LightRotY(light, float2angle(45));
\par \tab vrl_LightRotX(light, float2angle(45));
\par 
\par \tab camera = vrl_CameraCreate();
\par \tab vrl_CameraRotX(camera, float2angle(45));
\par \tab vrl_CameraMove(camera, 0, 500, \_500);
\par 
\par \tab vrl_SystemRun();
\par \tab \}
\par 
\par }{\f4\lang2057 
Notice that the only file we had to #include was "avril.h"; that file contains prototypes for all the AVRIL functions, along with a number of useful macros.  The avril.h file #includes <stdio.h> (since it references the FILE * type) so there's no need for
 you to do so yourself.  Since some of the macros in avril.h use the memcpy() function, the avril.h file will automatically #include whatever header file is needed to define memcpy(); this is <string.h> on most platforms.
\par 
\par \tab The program shown above simply cr
eates a cube, a light source and a virtual camera.  All the AVRIL routines and data types have names beginning with "vrl_"; this ensures that they won't conflict with any routines you write.  The vrl_SystemStartup() routine does all the system initializat
ion; the source code for all the vrl_System functions is found in system.c, in case you're curious as to how they work.  We'll be looking at them in detail later.
\par 
\par \tab Once the initialization is done, the program creates the cube by calling a routine that gene
rates a primitive box shape; the sides are all 100 units in length.  After it's been created, the cube is rotated 45 degrees around the vertical (Y) axis.  The float2angle() routine converts a floating-point number into an internal format used for storing
 angles.
\par 
\par \tab A directional light source is then created, and rotated 45 degrees in each of X and Y.  Next, a virtual camera is created, rotated and moved into position.  Finally, vrl_SystemRun() is called; vrl_SystemRun() sits in a loop, checking for keyboard
 or mouse activity and doing the rendering as needed.
\par 
\par \tab To compile and link the program using Borland C++, you would give the following command:
\par 
\par }{\cs20\f11\fs16\lang2057 \tab bcc -ml example1.c input.c avril.lib
\par }{\f4\lang2057 
\par This compiles example1.c and input.c and links them with the AVRIL library.  The routines in input.c are discussed in a later section.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Sharing Shapes}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par \tab Our first example was pretty straightforward; let's try something more complex.
\par 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 /* EXAMPLE2 \_\_ several asteroids, sharing the same geometry */
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 
\par /* Written by Bernie Roehl, April 1994 */
\par 
\par #include "avril.h"
\par #include <stdlib.h>  /* needed for rand() */
\par 
\par void main()
\par \tab \{
\par \tab FILE *infile;
\par \tab vrl_Light *light;
\par \tab vrl_Camera *camera;
\par \tab vrl_Shape *asteroidshape = NULL;
\par \tab int i;
\par 
\par \tab vrl_SystemStartup();
\par \tab 
\par \tab vrl_WorldSetHorizon(0);    /* turn off horizon */
\par \tab vrl_WorldSetSkyColor(0);   /* black sky */
\par 
\par \tab infile = fopen("asteroid.plg", "r");
\par \tab if (infile)
\par \tab \tab \{
\par \tab \tab asteroidshape = vrl_ReadPLG(infile);
\par \tab \tab fclose(infile);
\par \tab \tab \}
\par 
\par \tab light = vrl_LightCreate();
\par \tab vrl_LightRotY(light, float2angle(45));
\par \tab vrl_LightRotX(light, float2angle(45));
\par \tab vrl_LightSetIntensity(light, float2factor(0.9));
\par 
\par \tab camera = vrl_CameraCreate();
\par \tab vrl_CameraMove(camera, 0, 100, \_50);
\par 
\par \tab for (i = 0; i < 5; ++i)
\par \tab \tab \{
\par \tab \tab vrl_Object *obj = vrl_ObjectCreate(asteroidshape);
\par \tab \tab vrl_ObjectMove(obj, rand() % 1000, rand() % 1000, rand() % 1000);
\par \tab \tab \}
\par 
\par \tab vrl_SystemRun();
\par \tab \}
\par 
\par }{\f4\lang2057 When you run this program, look around using the arrow keys to spot the (stationary) asteroids.  This program illustrates a useful memory-saving feature of AVRIL.  The shape of
 an object (i.e., its geometric description) is separate from the information about its location and orientation.  Any number of objects can share the same geometric description, saving substantial amounts of memory.  A geometric description is called a v
rl_Shape, and consists of a set of vertices, facets and other information.
\par 
\par \tab The program shown above begins by turning off the horizon (it's on by default) and setting the sky color to 0 (black).  The sky color is used as the screen clear color if there's n
o horizon.  Next, the file "asteroid.plg" is loaded; AVRIL supports the PLG file format, described in Appendix C.  The vrl_ReadPLG() function returns a pointer to a vrl_Shape (the same data type that was returned by the vrl_PrimitiveBox() function in our 
first example).
\par 
\par \tab A light source and camera are again set up, and five virtual objects are created using the shape that was loaded by vrl_ReadPLG().  Notice that the file only had to be read once, and that the vertices and facets making up an asteroid are o
nly stored once in memory.  Each of the asteroids is moved to a random location in an imaginary box 1000 units on a side.
\par 
\par \tab 
As you move around, you'll notice that the appearance of an asteroid changes depending on how far away you are from it; if you get close enough, it's a rough, craggy surface.  The "asteroid.plg" file stores multiple representations of the object, and AVR
IL automatically selects one of those representations based on distance.  This can speed up the rendering process by allowing fewer vertices and facets to be used when an object is far away.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Making Maps}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab AVRIL not only separates 
geometry from location/orientation information, it also stores surface descriptions separately.  Each object has a "surface map" associated with it, which stores pointers to actual vrl_Surface specifiers.  Each surface has a type, a hue and a brightness; 
in our examples, the surface type is always SURFACE_FLAT (meaning that flat shading is used).  The hue is what most people think of as the "color", and the brightness is how much light the surface reflects back to the eye.  The higher the brightness value
 and the more directly that light is striking the surface, the more intense the color.
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab You can assign surface maps to objects, and change them whenever you like.  Our third example program uses two different surface maps, called }{\i\f4\lang2057 map1}{\f4\lang2057  and }{\i\f4\lang2057 map2}{\f4\lang2057 :
\par 
\par }{\cs20\f11\fs16\lang2057 /* EXAMPLE3 \_\_ surface maps */
\par 
\par /* Written by Bernie Roehl, April 1994 */
\par 
\par #include "avril.h"
\par #include <stdlib.h>  /* needed for rand() */
\par 
\par void main()
\par \tab \{
\par \tab FILE *infile;
\par \tab vrl_Light *light;
\par \tab vrl_Camera *camera;
\par \tab vrl_Shape *colorthing = NULL;
\par \tab vrl_Surfacemap *map1, *map2;
\par \tab int i;
\par 
\par \tab vrl_SystemStartup();
\par \tab 
\par \tab map1 = vrl_SurfacemapCreate(6);
\par \tab map2 = vrl_SurfacemapCreate(6);
\par \tab for (i = 0; i < 6; ++i)
\par \tab \tab \{
\par \tab \tab vrl_SurfacemapSetSurface(map1, i, vrl_SurfaceCreate(i + 1));
\par \tab \tab vrl_SurfacemapSetSurface(map2, i, vrl_SurfaceCreate(7 + i));
\par \tab \tab \}
\par 
\par \tab infile = fopen("colorful.plg", "r");
\par \tab if (infile)
\par \tab \tab \{
\par \tab \tab colorthing = vrl_ReadPLG(infile);
\par \tab \tab fclose(infile);
\par \tab \tab \}
\par 
\par \tab light = vrl_LightCreate();
\par \tab vrl_LightRotY(light, float2angle(45));
\par \tab vrl_LightRotX(light, float2angle(45));
\par 
\par \tab camera = vrl_CameraCreate();
\par \tab vrl_CameraMove(camera, 0, 100, \_50);
\par 
\par \tab for (i = 0; i < 10; ++i)
\par \tab \tab \{
\par \tab \tab vrl_Object *obj = vrl_ObjectCreate(colorthing);
\par \tab \tab if (i & 1)
\par \tab \tab \tab vrl_ObjectSetSurfacemap(obj, map1);
\par \tab \tab else
\par \tab \tab \tab vrl_ObjectSetSurfacemap(obj, map2);
\par \tab \tab vrl_ObjectMove(obj, rand() % 1000, rand() % 1000, rand() % 1000);
\par \tab \tab \}
\par 
\par \tab vrl_SystemRun();
\par \tab \}
\par 
\par }{\f4\lang2057 The program creates the two maps using the vrl_SurfacemapCreate() function; the parameter is the number of entries the map should have.  Six entries are then created in ea
ch map by calling vrl_SurfaceCreate(); the parameter to that function is the hue.  The first map will use hues 1 through 6 inclusive, the second will use hues 7 through 12.  A shape is then loaded from the file "colorful.plg"; that file uses indexed surfa
ce descriptors (0x8000, 0x8001 etc) that refer to entries in the surface map.  Refer to Appendix C for more details about surface descriptors.
\par 
\par \tab The light source and camera are again set up, and ten objects are created.  Half of them (the odd-numbered ones) are assigned }{\i\f4\lang2057 map1}{\f4\lang2057  and the others are assigned }{\i\f4\lang2057 map2}{\f4\lang2057 
.  The objects are again positioned randomly.
\par 
\par \tab 
Notice how half the cubes are a different color from the other half.  Each set of surface descriptions is only stored once, and each surface map is shared by five of the ten cubes.  All the cubes share the same vrl_Shape information, which is only stored
 once.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 A Real Taskmaster}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab 
AVRIL has a pseudo-tasking facility, which allows you to add routines to a list that gets processed continuously while the system runs.  Each task has a function and possibly some data, as well as an indication of how often it should be run.
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab Our fourth example is more complex that the first three; it creates several primitive shapes, sets up surface maps, and creates tasks to make the objects move by themselves.  We'll have spinning cubes, bouncing spheres and pulsating cylinders.
\par 
\par }{\cs20\f11\fs16\lang2057 /* EXAMPLE4 \_\_ simple object behaviours */
\par 
\par /* Written by Bernie Roehl, April 1994 */
\par 
\par #include "avril.h"
\par #include <stdlib.h>  /* needed for rand() */
\par 
\par static vrl_Angle spinrate;
\par static vrl_Time bounce_period;
\par static vrl_Scalar maxheight;
\par static vrl_Time pulse_period;
\par 
\par static void spin(void)
\par \tab \{
\par \tab vrl_ObjectRotY(vrl_TaskGetData(), vrl_TaskGetElapsed() * spinrate);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par 
\par static void bounce(void)
\par \tab \{
\par \tab vrl_Object *obj = vrl_TaskGetData();
\par \tab unsigned long off;
\par \tab vrl_Scalar height;
\par \tab off = (360 * (vrl_TaskGetTimeNow() % bounce_period)) / bounce_period;
\par \tab height = vrl_FactorMultiply(vrl_Sine(float2angle(off)), maxheight);
\par \tab vrl_ObjectMove(obj, vrl_ObjectGetWorldX(obj), height, vrl_ObjectGetWorldZ(obj));
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par 
\par static void pulsate(void)
\par \tab \{
\par \tab vrl_Surface *surf = vrl_SurfacemapGetSurface((vrl_Surfacemap *) vrl_TaskGetData(), 0);
\par \tab unsigned long off;
\par \tab int brightness;
\par \tab off = (360 * (vrl_TaskGetTimeNow() % pulse_period)) / pulse_period;
\par \tab brightness = abs(vrl_FactorMultiply(vrl_Sine(float2angle(off)), 255));
\par \tab vrl_SurfaceSetBrightness(surf, brightness);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par 
\par void main()
\par \tab \{
\par \tab vrl_Light *light;
\par \tab vrl_Camera *camera;
\par \tab vrl_Shape *cube, *sphere, *cylinder;
\par \tab vrl_Surfacemap *cubemap, *pulsemap;
\par \tab int i;
\par 
\par \tab vrl_SystemStartup();
\par \tab 
\par \tab cube = vrl_PrimitiveBox(100, 100, 100, NULL);
\par \tab sphere = vrl_PrimitiveSphere(100, 6, 6, NULL);
\par \tab cylinder = vrl_PrimitiveCylinder(100, 50, 100, 8, NULL);
\par 
\par \tab cubemap = vrl_SurfacemapCreate(1);
\par \tab vrl_SurfacemapSetSurface(cubemap, 0, vrl_SurfaceCreate(5));
\par \tab pulsemap = vrl_SurfacemapCreate(1);
\par \tab vrl_SurfacemapSetSurface(pulsemap, 0, vrl_SurfaceCreate(14));
\par 
\par \tab spinrate = float2angle(72.0 / vrl_TimerGetTickRate());  /* deg per tick */
\par \tab bounce_period = 4 * vrl_TimerGetTickRate();  /* four\_second period */
\par \tab maxheight = float2scalar(400);    /* maximum height in units */
\par \tab pulse_period =  2 * vrl_TimerGetTickRate();  /* two\_second period */
\par 
\par \tab light = vrl_LightCreate();
\par \tab vrl_LightRotY(light, float2angle(45));
\par \tab vrl_LightRotX(light, float2angle(45));
\par 
\par \tab camera = vrl_CameraCreate();
\par \tab vrl_CameraRotY(camera, float2angle(5));
\par \tab vrl_CameraMove(camera, 0, 200, \_4400);
\par 
\par \tab for (i = 0; i < 10; ++i)
\par \tab \tab \{
\par \tab \tab vrl_Object *obj = vrl_ObjectCreate(NULL);
\par \tab \tab vrl_ObjectMove(obj, rand() % 1000, rand() % 1000, rand() % 1000);
\par \tab \tab switch (i & 3)
\par \tab \tab \tab \{
\par \tab \tab \tab case 0:
\par \tab \tab \tab \tab vrl_ObjectSetShape(obj, cube);
\par \tab \tab \tab \tab break;
\par \tab \tab \tab case 1:
\par \tab \tab \tab \tab vrl_ObjectSetShape(obj, cube);
\par \tab \tab \tab \tab vrl_ObjectSetSurfacemap(obj, cubemap);
\par \tab \tab \tab \tab vrl_TaskCreate(spin, obj, 10);
\par \tab \tab \tab \tab break;
\par \tab \tab \tab case 2:
\par \tab \tab \tab \tab vrl_ObjectSetShape(obj, sphere);
\par \tab \tab \tab \tab vrl_TaskCreate(bounce, obj, 10);
\par \tab \tab \tab \tab break;
\par \tab \tab \tab case 3:
\par \tab \tab \tab \tab vrl_ObjectSetShape(obj, cylinder);
\par \tab \tab \tab \tab vrl_ObjectSetSurfacemap(obj, pulsemap);
\par \tab \tab \tab \tab break;
\par \tab \tab \tab \}
\par \tab \tab vrl_TaskCreate(pulsate, pulsemap, 10);
\par \tab \tab \}
\par 
\par \tab vrl_SystemRun();
\par \tab \}
\par 
\par }{\f4\lang2057 Let's start by looking
 at main().  Three primitive shapes are created -- a box (100 units on a side), a sphere (100 units in radius, with 6 facets around its "latitude" and 6 slices around its "longitude") and a tapered cylinder (base radius 100, top radius 50, height 100 unit
s with 8 sides).  Two surface maps are created, each with a single surface; one called }{\i\f4\lang2057 cubemap}{\f4\lang2057  using hue 5 and one called }{\i\f4\lang2057 pulsemap}{\f4\lang2057  using hue 14.
\par 
\par \tab Some global variables are then set; }{\i\f4\lang2057 spinrate}{\f4\lang2057  is the rate that the cubes should spin, in degrees per "tick".  A
 tick is a small unit of time; the timer runs at 1000 ticks per second, so each tick is one millisecond.  In case this changes, you should use the routine vrl_TimerGetTickRate() to found out how many ticks per second the timer is running at.
\par 
\par \tab 
We do the float2angle() conversion here rather than in the spin() task itself; by storing the vrl_Angle value, we avoid having to do the conversion each time through the simulation loop.  Also notice that we divide by the rate at which the system timer r
uns, in ticks per second; the rotation rate is 72 degrees per second, so we divide by ticks per second to get the rotation rate in degrees per tick.
\par 
\par \tab The }{\i\f4\lang2057 bounce_period}{\f4\lang2057  is 4 seconds, converted to ticks; this is the time it takes a bouncing ball to go through one complete up-down cycle.  The maximum height a ball will rise to is }{\i\f4\lang2057 maxheight}{
\f4\lang2057 , arbitrarily set to be 400 units.  Note the conversion from floating-point to the internal "vrl_Scalar" format.  The }{\i\f4\lang2057 pulse_period}{\f4\lang2057  is set to two seconds.
\par 
\par \tab Again, a light and camera are s
et up so we can view the scene, and ten objects are created and randomly positioned.  Some of them are simple cubes (using the default color assigned by vrl_PrimitiveBox()).  Some of them are spinning cubes, with a single-entry surfacemap.
\par 
\par \tab 
A task is created to make each cube spin.  Each task has a function, some data, and a "period" which indicates how often the task should be run.  In this case, the function is spin(), the data is a pointer to the object to be spun, and the period is 10 t
icks.  The perio
d doesn't affect the speed at which the cube will spin; it only determines how often the spin() function should be called.  The smaller the number, the more often the routine will run and the "smoother" the motion will be; of course, running the tasks mor
e often takes CPU cycles away from rendering.
\par 
\par \tab The bouncing balls are handled the same way as the spinning cubes.  The cylinders don't have a task associated with them; instead a separate task is set up that will cause the pulsing to happen.  The data for 
that task is not an object pointer, but rather a pointer to a surface map.
\par 
\par \tab The tasks themselves are quite straightforward.  The simplest is the spin() task, which is only two lines long:
\par 
\par }{\cs20\f11\fs16\lang2057 static void spin(void)
\par \tab \{
\par \tab vrl_ObjectRotY(vrl_TaskGetData(), vrl_TaskGetElapsed() * spinrate);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par }{\f4\lang2057 
\par This task gets a pointer to its data using vrl_TaskGetData(); this is a pointer to the object associated with this task.  The task also gets the elapsed time (in ticks) since it last ran, multiplies that value by }{\i\f4\lang2057 spinrate}{\f4\lang2057 
, and rotates the object by that amount around the vertical (Y) axis.  The spin() function then calls vrl_SystemRequestRefresh(), which tells the system that the screen should be refreshed (since an object has moved).
\par 
\par \tab The bounce() task is only slightly more complex; it uses the sine function to determine the height at which the object should be positioned:
\par 
\par }{\cs20\f11\fs16\lang2057 static void bounce(void)
\par \tab \{
\par \tab vrl_Object *obj = vrl_TaskGetData();
\par \tab unsigned long off;
\par \tab vrl_Scalar height;
\par \tab off = (360 * (vrl_TaskGetTimeNow() % bounce_period)) / bounce_period;
\par \tab height = vrl_FactorMultiply(vrl_Sine(float2angle(off)), maxheight);
\par \tab vrl_ObjectMove(obj, vrl_ObjectGetWorldX(obj), height, vrl_ObjectGetWorldZ(obj));
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par }{\f4\lang2057 
\par The current time is obtained from vrl_TaskGetTimeNow(), and the % operator is used to find the modulus (remainder) of the current time relative to the bounce period.  That value, divided by the bounce period, is the fraction of the bounce period that has 
elapsed.  We multip
ly that by 360 (the number of degrees in a circle) to get an offset value; we take the sine of that value (using the fast vrl_Sine() routine) and multiply by the maximum height value.  The vrl_FactorMultiply() routine takes a fractional number (of the typ
e returned by vrl_Sine()) and multiplies it by a vrl_Scalar value to get a (smaller) vrl_Scalar value.
\par 
\par \tab We use vrl_ObjectMove() to actually position the object.  Notice the use of vrl_ObjectGetWorldX() and vrl_ObjectGetWorldZ() to find the current X and Z 
values of the object's location; we don't want to alter those values, only the height.  A call to the function vrl_SystemRequestRefresh() ensures that the screen will be redrawn with the object at its new height.
\par 
\par \tab The pulsate() task is similar to the bounce() task, but instead of computing a height it computes a brightness and sets it as the new brightness value of the surface.  Brightness values are in the range of 0 to 255.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Left to Our Own Devices}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par \tab AVRIL supports the use of a variety of input devices for manipulating your viewpoint and the objects in your virtual world.  Our next example shows one way to use them.
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 /* EXAMPLE5 \_\_ manipulating a cube with the Logitech Cyberman */
\par 
\par /* Written by Bernie Roehl, August 1994 */
\par 
\par #include "avril.h"
\par #include "avrildrv.h"
\par 
\par vrl_Object *cube = NULL;
\par 
\par static void cube_mover(void)
\par \tab \{
\par \tab vrl_Device *dev = vrl_TaskGetData();
\par \tab vrl_Object *viewer = vrl_CameraGetObject(vrl_WorldGetCamera());
\par \tab vrl_Vector v;
\par \tab vrl_ObjectRotate(cube, vrl_DeviceGetValue(dev, YROT), Y, VRL_COORD_OBJREL, viewer);
\par \tab vrl_ObjectRotate(cube, vrl_DeviceGetValue(dev, XROT), X, VRL_COORD_OBJREL, viewer);
\par \tab vrl_ObjectRotate(cube, vrl_DeviceGetValue(dev, ZROT), Z, VRL_COORD_OBJREL, viewer);
\par \tab vrl_VectorCreate(v, vrl_DeviceGetValue(dev, X), vrl_DeviceGetValue(dev, Y),
\par \tab \tab vrl_DeviceGetValue(dev, Z));
\par \tab vrl_ObjectTranslate(cube, v, VRL_COORD_OBJREL, viewer);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par 
\par void main()
\par \tab \{
\par \tab vrl_Light *light;
\par \tab vrl_Camera *camera;
\par \tab vrl_Device *dev;
\par 
\par \tab vrl_SystemStartup();
\par 
\par \tab cube = vrl_ObjectCreate(vrl_PrimitiveBox(100, 100, 100, NULL));
\par \tab vrl_ObjectRotY(cube, float2angle(45));
\par 
\par \tab light = vrl_LightCreate();
\par \tab vrl_LightRotY(light, float2angle(45));
\par \tab vrl_LightRotX(light, float2angle(45));
\par 
\par \tab camera = vrl_CameraCreate();
\par \tab vrl_CameraRotX(camera, float2angle(45));
\par \tab vrl_CameraMove(camera, 0, 500, \_500);
\par 
\par \tab dev = vrl_DeviceOpen(vrl_CybermanDevice, vrl_SerialOpen(0x2F8, 3, 2000));
\par \tab if (dev)
\par \tab \tab \{
\par \tab \tab vrl_DeviceSetScale(dev, X, float2scalar(50));
\par \tab \tab vrl_DeviceSetScale(dev, Y, float2scalar(50));
\par \tab \tab vrl_DeviceSetScale(dev, Z, float2scalar(50));
\par \tab \tab vrl_TaskCreate(cube_mover, dev, 0);
\par \tab \tab \}
\par 
\par \tab vrl_SystemRun();
\par \tab \}
\par 
\par }{\f4\lang2057 
\par As you can see, there's not much to it.  Most of the code is exactly the same as our first example;  The only difference is that just before we start running the main loop, we open up a device.  The first parameter to the vrl_DeviceOpen() routine is the a
ddress of a function that is responsible for operating the device; in this case, it's called vrl_
CybermanDevice, and it reads the Logitech Cyberman.  Notice that we #included the avrildrv.h file; it has declarations for all the device functions.  When you create a new device driver (as described in Appendices F of the technical reference manual) you 
should put an entry into the avrildrv.h file for it.
\par 
\par \tab The second parameter to vrl_DeviceOpen() is a pointer to a serial port; we could have opened the serial port, assigned it to a variable, and passed that variable to the vrl_DeviceOpen() function, but there was no need to in this case.
\par 
\par \tab 
The values 0x2F8 and 3 are the hardware address and IRQ number of the COM2 port on a PC-compatible; this example is very platform-specific, but we'll see shortly how to get around that.  The value 2000 is the size of the input buffer the serial port shou
ld use.
\par 
\par \tab Assuming the device was successfully opened, we scale the X, Y and Z translation values read by the device to be 50 units; that will be the maximum number of world-space units per second that we can move objects u
sing this device.  Finally, we create a task whose data parameter is a pointer to our newly-opened device.
\par 
\par \tab The task that does the work of moving the object is called cube_mover().  You'll notice that unlike our first example program, we've declared the cube object as a global variable instead of a local one; this so that cube_mover() can access it.
\par 
\par \tab The cube_mover() task starts by getting the device pointer, and a pointer to the object corresponding to our viewpoint.
\par 
\par }{\cs20\f11\fs16\lang2057 \tab vrl_Device *dev = vrl_TaskGetData();
\par \tab vrl_Object *viewer = vrl_CameraGetObject(vrl_WorldGetCamera());
\par }{\f4\lang2057 
\par Next, cube_mover() rotates the cube.  First it does the Y axis, then the X axis, and finally the Z axis.  In each case, it rotates the cube relative to the viewer object by an amount that is read from the device.
\par 
\par }{\cs20\f11\fs16\lang2057 \tab vrl_ObjectRotate(cube, vrl_DeviceGetValue(dev, YROT),
\par \tab \tab Y, VRL_COORD_OBJREL, viewer);
\par \tab vrl_ObjectRotate(cube, vrl_DeviceGetValue(dev, XROT),
\par \tab \tab X, VRL_COORD_OBJREL, viewer);
\par \tab vrl_ObjectRotate(cube, vrl_DeviceGetValue(dev, ZROT),
\par \tab \tab Z, VRL_COORD_OBJREL, viewer);
\par }{\f4\lang2057 
\par The final step is to read the X, Y and Z translation values from the device, store them in a vector, and translate (move) the object along that vector relative to the viewer.
\par 
\par }{\cs20\f11\fs16\lang2057 \tab vrl_VectorCreate(v, vrl_DeviceGetValue(dev, X),
\par \tab \tab vrl_DeviceGetValue(dev, Y), vrl_DeviceGetValue(dev, Z));
\par \tab vrl_ObjectTranslate(cube, v, VRL_COORD_OBJREL, viewer);
\par \tab vrl_SystemRequestRefresh();
\par }{\f4\lang2057 
\par That's it.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 An Independence Movement}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab The example program above works fine.  If you have a Cyberman.  And if it's on COM2.  And if all you want to do is move a cube.  Wouldn't it be nice to have a little more flexibility?
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab As it turns out, you can.  AVRIL supports the use of "configuration files" that store information about a user's preferences and hardware configuration.  Our next example uses that configuration information to make our life simpler.
\par 
\par }{\cs20\f11\fs16\lang2057 /* EXAMPLE6 \_\_ using the configuration file to simplify setup */
\par 
\par /* Written by Bernie Roehl, August 1994 */
\par 
\par #include "avril.h"
\par 
\par static void object_manipulator(void)
\par \tab \{
\par \tab extern vrl_Object *active_object;  /* defined in input.c */
\par \tab vrl_Device *dev = vrl_TaskGetData();
\par \tab vrl_Object *viewer = vrl_CameraGetObject(vrl_WorldGetCamera());
\par \tab vrl_Vector v;
\par \tab vrl_ObjectRotate(active_object, vrl_DeviceGetValue(dev, YROT),
\par \tab \tab Y, VRL_COORD_OBJREL, viewer);
\par \tab vrl_ObjectRotate(active_object, vrl_DeviceGetValue(dev, XROT),
\par \tab \tab X, VRL_COORD_OBJREL, viewer);
\par \tab vrl_ObjectRotate(active_object, vrl_DeviceGetValue(dev, ZROT),
\par \tab \tab Z, VRL_COORD_OBJREL, viewer);
\par \tab vrl_VectorCreate(v, vrl_DeviceGetValue(dev, X),
\par \tab \tab vrl_DeviceGetValue(dev, Y), vrl_DeviceGetValue(dev, Z));
\par \tab vrl_ObjectTranslate(active_object, v, VRL_COORD_OBJREL, viewer);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par 
\par void main(int argc, char *argv[])
\par \tab \{
\par \tab vrl_Device *dev;
\par \tab vrl_SystemStartup();
\par \tab vrl_ReadCFGfile("example6.cfg");
\par \tab vrl_SystemCommandLine(argc, argv);
\par \tab dev = vrl_DeviceFind("manipulator");
\par \tab if (dev)
\par \tab \tab vrl_TaskCreate(object_manipulator, dev, 0);
\par \tab vrl_SystemRun();
\par \tab \}
\par }{\f4\lang2057 
\par Our main() is shorter, and simpler.  You'll notice that we've added a call to vrl_ReadCFGfile(); it reads the configuration file we specify (in this case it's "example6.cfg"), and configures and initializes all the devices (even opening the serial ports) 
as specified in the configuration file.  The format of the configuration file is described in Appendix B of the technical reference manual.
\par 
\par \tab The vrl_SystemCommandLine() function reads the command line, and loads whatever PLG files, FIG files and WLD files 
we specify there.  The vrl_DeviceFind() function looks for a device that was given the name "manipulator" in the configuration file, and if it finds one it creates a task to move an object using the manipulation device.
\par 
\par \tab The object_manipulator() function is almost the same as cube_mover(), but it uses an external variable called }{\i\f4\lang2057 active_object}{\f4\lang2057 
.  As we'll see later, this variable is found in input.c (where it gets set to the object most recently selected by the mouse).
\par 
\par \tab Using this program, we can explore a 
virtual world, click on objects to select them, and use the manipulator device we specify in our configuration file to manipulate the selected object.  All with just a few lines of code.  Note that if you're using the mouse to manipulate objects, you shou
ld hit the spacebar to toggle between selecting objects and moving them.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 A Smooth Operator}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab So far all the objects we've been looking at have been flat shaded; that gives them the distinctive "faceted" appearance that you often see in VR systems.  However
, AVRIL is capable of smooth shading as well, as shown in the following example:
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }{\cs20\f11\fs16\lang2057 /* EXAMPLE7 \_\_ Gouraud shading */
\par 
\par /* Written by Bernie Roehl, April 1995 */
\par 
\par #include "avril.h"
\par 
\par static void load_palette(char *filename)
\par \tab \{
\par \tab FILE *infile = fopen(filename, "rb");
\par \tab if (infile)
\par \tab \tab \{
\par \tab \tab vrl_PaletteRead(infile, vrl_WorldGetPalette());
\par \tab \tab fclose(infile);
\par \tab \tab \}
\par \tab \}
\par 
\par static vrl_Angle tumblerate;
\par 
\par void tumbler(void)
\par \tab \{
\par \tab vrl_Object *obj = vrl_TaskGetData();
\par \tab vrl_Angle amount = vrl_TaskGetElapsed() * tumblerate;
\par \tab vrl_ObjectRotY(obj, amount);
\par \tab vrl_ObjectRotX(obj, amount);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par 
\par void main()
\par \tab \{
\par \tab vrl_Shape *smooth_shape;
\par \tab vrl_Object *thing;
\par \tab vrl_Light *light;
\par \tab vrl_Camera *camera;
\par \tab vrl_Surface *surf;
\par 
\par \tab vrl_SystemStartup();
\par \tab 
\par \tab load_palette("shade32.pal");
\par 
\par \tab smooth_shape = vrl_PrimitiveCylinder(100, 25, 200, 16, NULL);
\par \tab vrl_ShapeComputeVertexNormals(smooth_shape);
\par 
\par \tab surf = vrl_SurfacemapGetSurface(vrl_ShapeGetSurfacemap(smooth_shape), 0);
\par \tab vrl_SurfaceSetType(surf, VRL_SURF_GOURAUD);
\par \tab vrl_SurfaceSetHue(surf, 4);
\par \tab vrl_SurfaceSetBrightness(surf, 243);
\par 
\par \tab thing = vrl_ObjectCreate(smooth_shape);
\par \tab vrl_ObjectRelMove(thing, 0, \_100, 0);
\par 
\par \tab vrl_WorldSetAmbient(0);
\par \tab light = vrl_LightCreate();
\par \tab vrl_LightRotY(light, float2angle(45));
\par 
\par \tab camera = vrl_CameraCreate();
\par \tab vrl_CameraMove(camera, 0, 0, \_1400);
\par 
\par \tab tumblerate = float2angle(72.0 / vrl_TimerGetTickRate());
\par \tab vrl_TaskCreate(tumbler, thing, 0);
\par 
\par \tab vrl_SystemRun();
\par \tab \}
\par }{\f4\lang2057 
\par Almost everything in Example 7 has been used in earlier examples, with three exceptions.  The fi
rst is the loading of a palette and hue map from a disk file, the second is the setting of the VRL_SURF_GOURAUD shading type on the surface used by the cone, and the third is the call to vrl_ShapeComputeVertexNormals().  In order for smooth (i.e., Gouraud
) shading to work, the renderer needs to know the normal vectors at each vertex; the vrl_ShapeComputeVertexNormals() routine computes them by averaging the facet normals.
\par 
\par \tab Technically, you don't need to call vrl_ShapeComputeVertexNormals() on spheres, cone
s and cylinders created by the vrl_Primitive family of functions; the creation routines do this automatically.  Shapes created by the vrl_PrimitiveBox() and vrl_PrimitivePrism() are flat-shaded by default.
\par 
\par \tab The shade32.pal file contains a palette and a hue map, set up to give fewer colors but more shades (in this case, 32 shades of each color instead of the standard 16).  This makes the Gouraud shading look a lot better.
\par 
\par \tab 
You may notice a number of glitches in the shading, especially little white flecks; that's because the Gouraud shading routine was the very last thing I added to this release, and it isn't fully debugged yet!  I should have that fixed up in version 2.1, b
ut I didn't want to leave out Gouraud shading altogether for this release.  I also didn't want to keep people waiting any longer for this release than I already have.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 A Tiny Program}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab AVRIL provides a number of useful utility routines that reduce the amount of actual programming you have to do in order to create a virtual world.  A minimal AVRIL program looks like this:
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }{\cs20\f11\fs16\lang2057 /* A very simple demo of AVRIL */
\par 
\par /* Written by Bernie Roehl, April 1994 */
\par 
\par #include "avril.h"
\par 
\par void main(int argc, char *argv[])
\par \tab \{
\par \tab vrl_SystemStartup();
\par \tab vrl_ReadCFGfile(NULL);
\par \tab vrl_SystemCommandLine(argc, argv);
\par \tab vrl_SystemRun();
\par \tab \}
\par }{\f4\lang2057 
\par The NULL parameter to vrl_ReadCFGfile() causes it to use its built-in default of "avril.cfg".  This example shows just how little it takes to create a VR program using AVRIL.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Of Mice and Menus}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab 
By now, you've probably noticed that something is missing; how have our programs been able to respond to our keystrokes and mouse presses?  Well, AVRIL does some of this for you automatically.  When you call vrl_SystemRun(), you're essentially turning co
ntrol of the application over to the system.  From time to time, the system will make calls back to your application to give you control if you need it.  (If you don't like this approach, you're not stuck with it; the
 source for the vrl_System functions is provided, so you can do things however you like).
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab 
There are currently five places that the system calls your application.  Just before starting its main internal loop for the first time, it calls vrl_ApplicationInit().  Just after it clears the screen (or draws the horizon, as the case may be) but befor
e it does the actual rendering of the scene, it calls vrl_ApplicationDrawUnder().  You can use that routine to "underlay" information on the screen that appears behin
d any objects that are drawn.  If you want to use your own background, just turn off screen clearing using vrl_WorldSetScreenClear(0) and do your background drawing in vrl_ApplicationDrawUnder().
\par 
\par \tab 
After the system has rendered the entire scene, it calls vrl_ApplicationDrawOver(); this allows you to "overlay" information on the screen.  The vrl_ApplicationDrawOver() routine is where you would put any "heads-up display" type information, such as fra
me rate or orientation information.
\par 
\par \tab Whenever a keystroke is detected, it's passed to the vrl_ApplicationKey() routine.  Similarly, mouse-up events are passed to the application using vrl_ApplicationMouseUp().
\par 
\par \tab 
All of these routines have default versions in the AVRIL library, so you don't have to write all of them.  The default versions of the functions vrl_ApplicationDrawUnder(), vrl_ApplicationDrawOver() and vrl_ApplicationMouseUp() are empty (i.e., they don'
t do anything).  The default version of vrl_ApplicationKey() just checks to see if the user has pressed the ESC key; if they have, vrl_SystemStopRunning() is called.
\par 
\par \tab In addition to all this, there's a simple menu system built into this version of AVRIL; it will be described later.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 A Moving Experience}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab 
Objects can have functions and data associated with them.  When the system walks through the hierarchy of objects, it calls each object's function; those functions can make use of the data associated with the object.
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab The default vrl_ApplicationInit() routine sets up an object function to let an input device (the keypad by default) move the user around.  You can look at the code in input.c for all the details, but essentially here's what it does:
\par 
\par }{\cs20\f11\fs16\lang2057 \tab vrl_Object *head = vrl_CameraGetObject(vrl_WorldGetCamera());
\par \tab vrl_Device *headdev = vrl_DeviceFind("head");
\par \tab if (headdev == NULL)
\par \tab \tab headdev = vrl_DeviceOpen(vrl_KeypadDevice, 0);
\par \tab vrl_ObjectSetApplicationData(head, headdev);
\par \tab vrl_ObjectSetFunction(head, head_mover);
\par }{\f4\lang2057 
\par If no head device was specified in the configuration file, the keypad is used.  The head is found (the head being the object to which the camera is attached), and the head object's application-specific data field is set to point to the headdev.
\par 
\par \tab 
The functions that are set on objects get called whenever the world is updated by the vrl_ObjectUpdate() or vrl_WorldUpdate() routines.  When object_move_locally() gets called, it just calls object_mover() on the object, passing the device pointer which 
is stored in the object's application data.
\par 
\par \tab The object_mover() routine is basically the same as the movement tasks that were described earlier (the ones in example 6) but slightly more general.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Lots of Input}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab 
The file input.c contains simple versions of vrl_ApplicationDrawOver(), vrl_ApplicationMouseUp(), vrl_ApplicationKey() and vrl_ApplicationInit() that are shared by all our example programs.  The vrl_ApplicationMouseUp() routine looks like this:
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 
\par vrl_Object *active_object = NULL;  /* points to the currently-selected object, if any */
\par 
\par void vrl_ApplicationMouseUp(int x, int y, unsigned int buttons)
\par \tab \{
\par \tab vrl_Object *old_active = active_object;
\par \tab if ((buttons & 1) == 0)
\par \tab \tab return;
\par \tab vrl_RenderMonitorInit(x, y);
\par \tab vrl_SystemRender(NULL);  /* redraw screen */
\par \tab if (vrl_RenderMonitorRead(&active_object, NULL, NULL))
\par \tab \tab \{
\par \tab \tab if (active_object == old_active)
\par \tab \tab \tab active_object = NULL;
\par \tab \tab else
\par \tab \tab \tab vrl_ObjectSetHighlight(active_object, 1);
\par \tab \tab \}
\par \tab if (old_active)
\par \tab \tab vrl_ObjectSetHighlight(old_active, 0);
\par \tab vrl_SystemRequestRefresh();
\par \tab \}
\par }{\f4\lang2057 
\par This routine uses the "Monitor" facility of AVRIL to allow the user to select objects.  The mouse location is passed to vrl_RenderMonitorInit(); this tells the system to keep an eye on that point on the screen.  The screen is then re-drawn using vrl_Syste
mRender(), and the monitor is read using vrl_RenderMonitorRead().  If that function returns a non-zero value, then the mouse cursor was on top of an object; since we passed }{\i\f4\lang2057 &active_object}{\f4\lang2057 
 to the vrl_RenderMonitorRead() function, }{\i\f4\lang2057 active_object}{\f4\lang2057  now points to 
the object that the mouse cursor was on top of.  This is the object that got moved around by the manipulation device in example 6.  If the user clicks again on the previously-selected object, then the }{\i\f4\lang2057 active_object}{\f4\lang2057 
 is set to NULL; otherwise, the newly-activated object gets its highlighting turned on.  In any case, we un-highlight the previously active object, and tell the system the screen needs to be refreshed (since the highlighting of an object has changed).

\par 
\par \tab The vrl_ApplicationKey() routine is very simple; the only complicated part is that it handles auto-repeat of keystrokes:
\par 
\par }{\cs20\f11\fs16\lang2057 void vrl_ApplicationKey(unsigned int c)
\par \tab \{
\par \tab static int lastkey = 0;
\par \tab if (c == INS)
\par \tab \tab \{
\par \tab \tab int i;
\par \tab \tab for (i = 0; i < 100; ++i)
\par \tab \tab \tab \{
\par \tab \tab \tab process_key(lastkey);
\par \tab \tab \tab vrl_SystemRender(vrl_WorldUpdate());
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab else
\par \tab \tab process_key(lastkey = c);
\par \tab \}
\par 
\par }{\f4\lang2057 If the key is INS (defined in avrilkey.h), the last key is re-processed 100 times; all other keys are processed once, and the }{\i\f4\lang2057 lastkey}{\f4\lang2057  variable is updated.  Notice the call to vrl_SystemRender()
; it looks pretty complicated, but after you read some of the later sections it will make more sense.  We need to update the world and re-render the scene after every keystroke, so the user will see the ongoing changes.
\par 
\par \tab 
The process_key() function is fairly long, and will probably change from version to version of AVRIL.  Most of it should be pretty easy to understand, so you may want to take a few minutes to look through the source code in input.c (where you'll also fin
d the source for the vrl_ApplicationMouseUp() and vrl_ApplicationDrawOver() routines).
\par 
\par \tab The vrl_ApplicationDrawOver() routine provides the position, frame rate, compass and "heads-up display" support for the AVRIL demos.  It looks like this:
\par 
\par }{\cs20\f11\fs16\lang2057 void vrl_ApplicationDrawOver(vrl_RenderStatus *stat)
\par \tab \{
\par \tab vrl_Camera *cam = vrl_WorldGetCamera();
\par \tab char buff[100];
\par \tab if (vrl_ConfigGetPositionDisplay())
\par \tab \tab \{
\par \tab \tab sprintf(buff, "Position: %ld,%ld", vrl_CameraGetWorldX(cam),
\par \tab \tab \tab vrl_CameraGetWorldZ(cam));
\par \tab \tab vrl_UserInterfaceDropText(10, 10, 15, buff);
\par \tab \tab \}
\par \tab if (vrl_ConfigGetFramerateDisplay())
\par \tab \tab \{
\par \tab \tab sprintf(buff, "Frames/sec: %ld", vrl_SystemGetFrameRate());
\par \tab \tab vrl_UserInterfaceDropText(5, 170, 15, buff);
\par \tab \tab \}
\par \tab if (vrl_ConfigGetCompassDisplay())
\par \tab \tab vrl_UserInterfaceDrawCompass(cam, 250, 40, 35);
\par \tab if (showhud)
\par \tab \tab \{
\par \tab \tab sprintf(buff, "%c%c%c",
\par \tab \tab \tab stat\_>memory ?  'M' : ' ',
\par \tab \tab \tab stat\_>objects ? 'O' : ' ',
\par \tab \tab \tab stat\_>facets ?  'F' : ' ');
\par \tab \tab vrl_UserInterfaceDropText(10, 20, 15, buff);
\par \tab \tab \}
\par \tab if (vrl_MouseGetUsage())
\par \tab \tab \{
\par \tab \tab vrl_Device *dev = vrl_MouseGetPointer();
\par \tab \tab if (dev)
\par \tab \tab \tab \{
\par \tab \tab \tab int x = vrl_DeviceGetCenter(dev, X);
\par \tab \tab \tab int y = vrl_DeviceGetCenter(dev, Y);
\par \tab \tab \tab int deadx = vrl_DeviceGetDeadzone(dev, X);
\par \tab \tab \tab int deady = vrl_DeviceGetDeadzone(dev, Y);
\par \tab \tab \tab /* white inner box */
\par \tab \tab \tab vrl_DisplayLine(x \_ deadx, y \_ deady, x + deadx, y \_ deady, 15);
\par \tab \tab \tab vrl_DisplayLine(x \_ deadx, y + deady, x + deadx, y + deady, 15);
\par \tab \tab \tab vrl_DisplayLine(x \_ deadx, y \_ deady, x \_ deadx, y + deady, 15);
\par \tab \tab \tab vrl_DisplayLine(x + deadx, y \_ deady, x + deadx, y + deady, 15);
\par \tab \tab \tab /* black outer box */
\par \tab \tab \tab vrl_DisplayLine(x\_deadx\_1, y\_deady\_1, x+deadx+1, y\_deady\_1, 0);
\par \tab \tab \tab vrl_DisplayLine(x\_deadx\_1, y+deady+1, x+deadx+1, y+deady+1, 0);
\par \tab \tab \tab vrl_DisplayLine(x\_deadx\_1, y\_deady\_1, x\_deadx\_1, y+deady+1, 0);
\par \tab \tab \tab vrl_DisplayLine(x+deadx+1, y\_deady\_1, x+deadx+1, y+deady+1, 0);
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \}
\par }{\f4\lang2057 
\par There are several "configuration" settings that get accessed to determine what information should be overlaid on the display; the state of those configuration variables is toggled by code in process_key().  This configuration information will be expl
ained in more detail later, in the section about configuration files.
\par 
\par \tab The call to vrl_WorldGetCamera() returns a pointer to the currently-active virtual camera.  The buffer }{\i\f4\lang2057 buff[]}{\f4\lang2057  will be used to construct strings that we want to display on the screen.
\par 
\par \tab 
If the user wants their location displayed, a text string containing the camera's current X and Z values is constructed and displayed at location (10, 10) on the screen.  The first value is the horizontal distance in pixels from the left of the screen, an
d the second value is the vertical distance in pixels from the top of the screen.  The color used is 15, which is white.  The vrl_UserInterfaceDropText() function automatically produces a "drop shadow" behind the text, ensuring it's visible even if it's o
verlaid on top of a white background.
\par 
\par \tab If the user wants a compass to be shown, the vrl_UserInterfaceDrawCompass() routine is called.  The compass is displayed at location (250, 40) on the screen, and each "arm" of the compass is 35 pixels long.
\par 
\par \tab If the }{\i\f4\lang2057 showhud}{\f4\lang2057 
 variable is set, a variety of debugging information is displayed.  When the renderer draws a scene, it may run out of internal memory, or it may find there are too many objects or facets for it to process.  If this happens, it sets bits in a special stru
cture; a pointer to this structure is passed to vrl_ApplicationDrawOver(), so that it can alert the user to the problem.  In this case, an 'M' is displayed if the renderer ran out of memory, an 'O' is displayed if there were too many objects, and an '
F' is displayed if there were too many facets.
\par 
\par \tab 
If the mouse is in 6D input device mode, a small square is drawn on the screen; if the mouse cursor is inside this box, there'll be no movement.  It's sort of a visual "dead zone", if you will.  The idea for this box came from a demo of the Superscape VR
 system; it was a clever enough idea that I adopted it for this example.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Into the System}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par \tab We've talked a lot so far about the vrl_System routines; now let's take a closer look at how they work.
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 vrl_Boolean vrl_SystemStartup(void)
\par \tab \{
\par \tab vrl_MathInit();
\par \tab vrl_WorldInit(vrl_WorldGetCurrent());
\par \tab if (vrl_VideoSetup(0))
\par \tab \tab \{
\par \tab \tab printf("Could not enter graphics mode!\\n");
\par \tab \tab return \_1;
\par \tab \tab \}
\par \tab atexit(vrl_VideoShutdown);
\par \tab if (vrl_DisplayInit(NULL))
\par \tab \tab return \_1;
\par \tab atexit(vrl_DisplayQuit);
\par \tab vrl_MouseInit();
\par \tab atexit(vrl_MouseQuit);
\par \tab if (vrl_TimerInit())
\par \tab \tab return \_2;
\par \tab atexit(vrl_TimerQuit);
\par \tab if (vrl_RenderInit(800, 800, 500, 5, 65000))
\par \tab \tab return \_3;
\par \tab atexit(vrl_RenderQuit);
\par \tab atexit(vrl_DeviceCloseAll);
\par \tab atexit(vrl_SerialCloseAll);
\par \tab /* make sure that exit() [and therefore the atexit() functions] get
\par \tab    called if there are any fatal errors */
\par \tab signal(SIGABRT, exit);
\par \tab signal(SIGFPE, exit);
\par \tab signal(SIGILL, exit);
\par \tab signal(SIGINT, exit);
\par \tab signal(SIGSEGV, exit);
\par \tab signal(SIGTERM, exit);
\par \tab vrl_SystemStartRunning();
\par \tab vrl_SystemRequestRefresh();
\par \tab vrl_SystemRender(NULL);
\par \tab return 0;
\par \tab \}
\par }{\f4\lang2057 
\par The vrl_SystemStartup() routine does the initialization of all the various AVRIL subsystems.  It starts by calling vrl_MathInit(), which sets up the t
rig tables used internally by AVRIL (for example, a table of sines that's used by the vrl_Sine() function described earlier).
\par 
\par \tab Next, the world is initialized and the video subsystem is started up; from this point on, the system is running in graphics mode.  The display subsystem is then initialized, followed by the mouse and the timer.
\par 
\par \tab After that, the rendering engine itself is initialized;
 the parameters to the vrl_RenderInit() function may change with a future release of the software, but for now just use the values that are shown above.  The value 65000 is the amount of memory the renderer should allocate for its internal use; if the ren
derer needs more than this amount of memory when rendering a scene, it will set the "memory" value in the status struct described earlier (which is passed to vrl_ApplicationDrawOver()).  If the renderer is unable to initialize itself (for example, if it c
ouldn't allocate the specified amount of memory) then vrl_RenderInit() returns a non-zero value.
\par 
\par \tab 
Notice the use of atexit() to ensure that everything is shut down properly when the program exits.  The signal() calls ensure that the exit() routine will be called in case of any errors; exit() will in turn call the various atexit() functions, cleanly c
losing down the system.
\par 
\par \tab Finally, vrl_SystemStartRunning() is called and an initial display refresh is requested.  The vrl_SystemStartRunning(), vrl_SystemStopR
unning(), and vrl_SystemIsRunning() routines are used to control whether the system is currently "running" or not.  They just set and check the value of the variable }{\i\f4\lang2057 system_is_running}{\f4\lang2057 
; however, using the routines makes your code a bit more readable.  It's also possible to redefine those routines to do something in addition to just setting or clearing a flag.
\par 
\par \tab The vrl_SystemRun() routine is the main loop of every AVRIL application.  It looks like this:
\par 
\par }{\cs20\f11\fs16\lang2057 void vrl_SystemRun(void)
\par \tab \{
\par \tab vrl_ApplicationInit();
\par \tab if (vrl_WorldGetStereoConfiguration())
\par \tab \tab vrl_StereoConfigure(vrl_WorldGetStereoConfiguration());
\par \tab while (vrl_SystemIsRunning())
\par \tab \tab \{
\par \tab \tab vrl_Object *list;
\par \tab \tab if (vrl_KeyboardCheck())
\par \tab \tab \tab vrl_ApplicationKey(vrl_KeyboardRead());
\par \tab \tab check_mouse();
\par \tab \tab vrl_TaskRun();
\par \tab \tab vrl_DevicePollAll();
\par \tab \tab list = vrl_WorldUpdate();
\par \tab \tab if (vrl_SystemQueryRefresh())
\par \tab \tab \tab vrl_SystemRender(list);
\par \tab \tab \}
\par \tab \}
\par }{\f4\lang2057 
\par It shouldn't come as any surprise that this looks like an event loop in a GUI application; on some systems, that's exactly how vrl_SystemRu
n() will be implemented.  However, on a DOS platform it's necessary to explicitly check the mouse and keyboard for activity.
\par 
\par \tab If a key has been pressed, the keyboard is read and the value of the key is passed to vrl_ApplicationKey().  The function check_mouse() is used to interrogate the mouse for updates:
\par 
\par }{\cs20\f11\fs16\lang2057 static void check_mouse(void)
\par \tab \{
\par \tab unsigned int mouse_buttons;
\par \tab if (vrl_MouseGetUsage())  /* being used as 6D pointing device */
\par \tab \tab return;
\par \tab if (!vrl_MouseRead(NULL, NULL, NULL))  /* mouse hasn't changed */
\par \tab \tab return;
\par \tab vrl_MouseRead(NULL, NULL, &mouse_buttons);
\par \tab if (mouse_buttons)  /* button down */
\par \tab \tab \{
\par \tab \tab int mouse_x, mouse_y;
\par \tab \tab vrl_ScreenPos win_x, win_y;
\par \tab \tab unsigned int down_buttons = mouse_buttons;
\par \tab \tab vrl_DisplayGetWindow(&win_x, &win_y, NULL, NULL);
\par \tab \tab while (mouse_buttons)  /* wait for button release */
\par \tab \tab \tab vrl_MouseRead(&mouse_x, &mouse_y, &mouse_buttons);
\par \tab \tab if (down_buttons & 0x07)
\par \tab \tab \tab vrl_ApplicationMouseUp(mouse_x \_ win_x, mouse_y \_ win_y, down_buttons);
\par \tab \tab \}
\par \tab \}
\par }{\f4\lang2057 
\par The vrl_MouseGetUsage() call is necessary because the mouse can be used in either of two completely different ways: as a pointing device for selecting objects on the screen, or as a 6 Degree-Of-Freedom (6D) input device; the 6D mode is described later, in
 the section on input devices.  If vrl_MouseGetUsage() returns a non-zero value, then the mouse is being used as a 6D input device, and input from it shouldn't be processed any further at this point.
\par 
\par \tab If the mouse hasn't changed location or button status, 
the call to vrl_MouseRead() will return zero, in which case no further processing is done.  If the mouse buttons are down, the routine tracks the mouse input until the buttons are released.  The button status is saved in the variable }{\i\f4\lang2057 
down_buttons}{\f4\lang2057 , and then passed to the routine vrl_ApplicationMouseUp() along with the mouse cursor location in the current window.
\par 
\par \tab Back in vrl_SystemRun(), the vrl_TaskRun() function is called to run all the tasks that have been created (like the spin(), bounce() and pulsate()
 tasks we used in example 4).  The input devices are polled, and vrl_WorldUpdate() is called; it walks the hierarchical tree of objects in the world, updating their location and orientation information and threading them onto a linked list which is return
ed as the value of the vrl_WorldUpdate() function.  Walking the tree also causes the function associated with each object to be called.
\par 
\par \tab If the display needs to be redrawn (i.e. the vrl_SystemRequestRefresh() routine that we mentioned earlier has been call
ed at least once since we last re-drew the screen) then the vrl_SystemRender() routine is called, and is given the linked list of objects to render.
\par 
\par \tab 
The vrl_SystemRender() routine does the actual updating of the screen.  Even though source is provided, you should use this routine as-is; it's likely to change in future releases of AVRIL, and several additional features will be added.  The code current
ly looks like this:
\par }\pard \keep\keepn\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }{\cs20\f11\fs16\lang2057 vrl_RenderStatus *vrl_SystemRender(vrl_Object *list)
\par \tab \{
\par \tab static vrl_Object *lastlist = NULL;
\par \tab vrl_Palette *pal;
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 \tab vrl_StereoConfiguration *conf;
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\cs20\f11\fs16\lang2057 \tab vrl_RenderStatus *stat;
\par \tab int pagenum;
\par \tab int two_eyes = 0;
\par \tab vrl_Time render_start = vrl_TimerRead();
\par \tab if (list == NULL)
\par \tab \tab list = lastlist;
\par \tab else
\par \tab \tab lastlist = list;
\par \tab pal = vrl_WorldGetPalette();
\par \tab if (vrl_PaletteHasChanged(pal))
\par \tab \tab \{
\par \tab \tab vrl_VideoSetPalette(0, 255, pal);
\par \tab \tab vrl_PaletteSetChanged(pal, 0);
\par \tab \tab \}
\par \tab pagenum = vrl_VideoGetDrawPage();
\par \tab if (++pagenum >= vrl_VideoGetNpages())
\par \tab \tab pagenum = 0;
\par \tab vrl_VideoSetDrawPage(pagenum);
\par \tab vrl_RenderSetAmbient(vrl_WorldGetAmbient());
\par \tab vrl_DisplayStereoSetDrawEye(VRL_STEREOEYE_BOTH);
\par \tab if (vrl_WorldGetScreenClear())
\par \tab \tab \{
\par \tab \tab vrl_DisplayBeginFrame();
\par \tab \tab if (vrl_WorldGetHorizon() && !vrl_RenderGetDrawMode())
\par \tab \tab \tab vrl_RenderHorizon();
\par \tab \tab else
\par \tab \tab \tab vrl_DisplayClear(vrl_WorldGetSkyColor());
\par \tab \tab vrl_DisplayEndFrame();
\par \tab \tab \}
\par \tab vrl_ApplicationDrawUnder();
\par \tab conf = vrl_WorldGetStereoConfiguration();
\par \tab if (conf)
\par \tab \tab two_eyes = vrl_StereoGetNeyes(conf);
\par \tab if (vrl_WorldGetStereo() && vrl_WorldGetLeftCamera()
\par \tab \tab && vrl_WorldGetRightCamera() && two_eyes)
\par \tab \tab \{
\par \tab \tab /* draw left\_eye image */
\par \tab \tab vrl_DisplayStereoSetDrawEye(VRL_STEREOEYE_LEFT);
\par \tab \tab vrl_RenderSetHorizontalShift(vrl_StereoGetTotalLeftShift(conf));
\par \tab \tab vrl_DisplayBeginFrame();
\par \tab \tab vrl_RenderBegin(vrl_WorldGetLeftCamera(), vrl_WorldGetLights());
\par \tab \tab stat = vrl_RenderObjlist(list);
\par \tab \tab vrl_DisplayEndFrame();
\par 
\par \tab \tab /* draw right\_eye image */
\par \tab \tab vrl_DisplayStereoSetDrawEye(VRL_STEREOEYE_RIGHT);
\par \tab \tab vrl_RenderSetHorizontalShift(vrl_StereoGetTotalRightShift(conf));
\par \tab \tab vrl_RenderBegin(vrl_WorldGetRightCamera(), vrl_WorldGetLights());
\par \tab \tab vrl_DisplayBeginFrame();
\par \tab \tab stat = vrl_RenderObjlist(list);
\par \tab \tab vrl_DisplayEndFrame();
\par \tab \tab \}
\par \tab else  /* not two\_eye stereo */
\par \tab \tab \{
\par \tab \tab vrl_DisplayStereoSetDrawEye(VRL_STEREOEYE_BOTH);
\par \tab \tab vrl_RenderSetHorizontalShift(0);
\par \tab \tab vrl_DisplayBeginFrame();
\par \tab \tab vrl_RenderBegin(vrl_WorldGetCamera(), vrl_WorldGetLights());
\par \tab \tab stat = vrl_RenderObjlist(list);
\par \tab \tab vrl_DisplayEndFrame();
\par \tab \tab \}
\par \tab vrl_DisplayStereoSetDrawEye(VRL_STEREOEYE_BOTH);
\par \tab vrl_RenderSetHorizontalShift(0);
\par \tab vrl_ApplicationDrawOver(stat);
\par \tab vrl_VideoCursorHide();
\par \tab vrl_DisplayUpdate();
\par \tab vrl_VideoSetViewPage(pagenum);
\par \tab vrl_VideoCursorShow();
\par \tab last_render_ticks = vrl_TimerRead() \_ render_start;
\par \tab need_to_redraw = 0;
\par \tab return stat;
\par \tab \}
\par }{\f4\lang2057 
\par First, the current time is stored in the variable }{\i\f4\lang2057 render_start}{\f4\lang2057 ; this is later used to compute the frame rate.
\par 
\par \tab If the list that the vrl_SystemRender() routine is given is NULL (as was the case in our example vrl_ApplicationMouseUp() routine in input.c) then the last list of objects ren
dered is used.  If the palette has changed since the last frame, it gets copied to the hardware palette and the "changed" flag is cleared.
\par 
\par \tab 
The system uses the concept of a "draw" page (on which drawing takes place) and a "view" page (which is the one the user is currently viewing).  The vrl_SystemRender() routine gets the current drawing page number, and increments it (so we start drawing o
n the next page).  It wraps back to page zero after it's drawn the last available display page.
\par \tab The ambient light level is set according to that of the current world.  If it's necessary to clear the screen, the system does so (or draws a horizon, as appropriate).  Then the vrl_ApplicationDrawUnder() routine we looked at earlier is called.

\par 
\par \tab 
A check is made to see if we're configured for stereoscopic viewing.  If we are, and if both the left and right eye cameras exist, and if it's a "two-eye" system (i.e., not Chromadepth or SIRDS) then the left eye image is drawn followed by the right eye 
image.  If we're not doing two-eye stereoscopic rendering, a single image is drawn.
\par 
\par \tab 
To draw an image, we start by selecting an eye and setting a corresponding horizontal offset.  Next, we tell the display subsystem to get ready for a new frame, tell the rendering engine about our camera and lights (using vrl_RenderBegin()), and call vrl
_RenderObjlist() to actually draw the objects.  Finally, we tell the display subsystem that the frame is complete.
\par 
\par \tab The vrl_ApplicationDrawOver() routine is then called to put any additional information
 on the display.  The cursor is hidden, and vrl_DisplayUpdate() is called; this is necessary, since some display systems don't have multiple pages and instead use an off-screen buffer which the vrl_DisplayUpdate() routine copies to the screen.  For system
s that have multiple-page displays, the current view page is set to the (now finished) drawing page.  The mouse cursor is then revealed again, the time it took to do all this is noted, and the }{\i\f4\lang2057 need_to_redraw}{\f4\lang2057 
 variable (which was set by vrl_SystemRequestRefresh()) is cleared.
\par 
\par \tab The final vrl_System routine is vrl_SystemCommandLine().  It just goes through the command-line parameters and calls the appropriate routines to read the various types of files:
\par 
\par }{\cs20\f11\fs16\lang2057 void vrl_SystemCommandLine(int argc, char *argv[])
\par \tab \{
\par \tab int i;
\par \tab vrl_Camera *cam;
\par \tab for (i = 1; i < argc; ++i)  /* i = 1 to skip argv[0] */
\par \tab \tab \{
\par \tab \tab FILE *in = fopen(argv[i], "r");
\par \tab \tab if (in == NULL) continue;
\par \tab \tab if (strstr(argv[i], ".wld"))
\par \tab \tab \tab vrl_ReadWLD(in);
\par \tab \tab else if (strstr(argv[i], ".fig"))
\par \tab \tab \tab vrl_ReadFIG(in, NULL, NULL);
\par \tab \tab else if (strstr(argv[i], ".plg"))
\par \tab \tab \tab vrl_ReadObjectPLG(in);
\par \tab \tab /* ignore anything else */
\par \tab \tab fclose(in);
\par \tab \tab \}
\par \tab if (!vrl_WorldGetCamera())   /* need to have a camera */
\par \tab \tab vrl_CameraCreate();
\par \tab vrl_WorldUpdate();
\par \tab \}
\par }{\f4\lang2057 
\par After all the files on the command line have been processed, the vrl_SystemCommandLine() routine checks to see if a current camera has been set.  If not, a new camera is created.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Configuration Files}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 AVRIL supports the loading of configuration files; the format of these files is given in Appendix B of the technical reference manual.  The functions that support loading configuration information are

\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }{\cs20\f11\fs16\lang2057 \tab int vrl_ReadCFG(FILE *in);
\par \tab int vrl_ReadCFGfile(char *filename);
\par }{\f4\lang2057 
\par The vrl_ReadCFG() function reads a configuration file and stores the information from it in a set of internal data structures.  Any devices specified in the file are opened, and the serial ports they use are opened as well.  If a display driver is specifi
ed, the display is initialized using that driver.  The vrl_ReadCFGfile() routine does the same thing, but uses the name of a file rather than a pointer to an already-opened file.  The filename is processed to prepend the current loadpath (unless the filen
ame begins with a slash).  If the filename is NULL, then "avril.cfg" is used.
\par 
\par \tab There are routines for reading, setting and toggling the various flags that the user can specify in the configuration file:
\par 
\par }{\cs20\f11\fs16\lang2057 \tab void vrl_ConfigSetCompassDisplay(vrl_Boolean flag);
\par \tab vrl_Boolean vrl_ConfigGetCompassDisplay(void);
\par \tab void vrl_ConfigToggleCompassDisplay(void);
\par \tab void vrl_ConfigSetPositionDisplay(vrl_Boolean flag);
\par \tab vrl_Boolean vrl_ConfigGetPositionDisplay(void);
\par \tab void vrl_ConfigTogglePositionDisplay(void);
\par \tab void vrl_ConfigSetFramerateDisplay(vrl_Boolean flag);
\par \tab vrl_Boolean vrl_ConfigGetFramerateDisplay(void);
\par \tab void vrl_ConfigToggleFramerateDisplay(void);
\par }{\f4\lang2057 
\par If you wanted to let the user specify a configuration file to load by setting the AVRIL environment variable, you would make the following call:
\par 
\par }{\cs20\f11\fs16\lang2057 \tab vrl_ReadCFGfile(getenv("AVRIL"));}{\cs20\f4\lang2057 
\par }{\f4\lang2057 
\par If no AVRIL environment variable is found, getenv() will return NULL and avril.cfg will be used.
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 That's All, Folks!}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par \tab For more detailed information about AVRIL, check out the AVRIL reference manual.  It contains an in-depth description of all the AVRIL functions and data types.
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab 
If you have problems using AVRIL, drop me a line via email.  My address is broehl@sunee.uwaterloo.ca; be sure to put AVRIL in the subject line so I know what it's about, otherwise it might take me days to get back to you.  (It might anyway...)
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Support for AVRIL}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab There are two electronic mailing lists for discussing AVRIL.  The first list is called }{\i\f4\lang2057 avril-announce}{\f4\lang2057 
, and is used for announcements of new releases, utilities, applications and so on.  The second list is called }{\i\f4\lang2057 avril-developers}{\f4\lang2057 
, and is used as a way for people who are developing applications using AVRIL to communicate and exchange ideas.
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab To subscribe to either or both lists, send mail to majordomo@sunee.uwaterloo.ca with the following line(s) in the body of the message:
\par 
\par }{\cs20\f11\fs16\lang2057 \tab subscribe avril-announce YourName
\par \tab subscribe avril-developers YourName
\par }{\f4\lang2057 
\par To unsubscribe from either or both lists, do the exact same thing but with the word "unsubscribe" instead of the word "subscribe".
\par }\pard\plain \s19\keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }{\b\f4\fs29\lang2057 Future Features}{\f4\lang2057 
\par }\pard\plain \keep\keepn\nowidctlpar\tx-720\hyphpar0 \f51 {\f4\lang2057 
\par }\pard \keep\nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 \tab Features that will be added in future releases include routines for sound, networking, and an application language of some sort.  I also hope to add Z-buffering and texture mapping.
\par }\pard \nowidctlpar\tx-720\hyphpar0 {\f4\lang2057 
\par \tab The latest release of AVRIL can always be found on sunee.uwaterloo.ca, in the pub/avril directory.  I will also try to put the latest version on major sites such as ftp.wustl.edu, oak.oakland.edu, x2ftp.oulu.fi and possibly others.  Please
 feel free to make it available to everyone; the only restrictions are that you can't sell it (since it's free!) and you can't develop commercial applications without properly licensing it.
\par 
\par \tab There should be a new release of AVRIL every few months; starting with version 2.5, AVRIL should be ported to several other platforms.
\par 
\par \tab One sad note: after many years of cheerfully using Borland C, I've decided to move on.  All the new features I want to add (Z-buffering, texture mapping, higher resolutions, support f
or 16- and 24-bit color) all require lots of memory.  The old 640k barrier is just too much of a limitation, so I'm going to protected mode.  The best protected mode compiler is Watcom C, and I've already started the conversion.
\par 
\par \tab What does this mean for users of AVRIL?  Well, it might mean buying a new compiler.  However, I may try to port AVRIL to DJGPP, a freeware C compiler based on GNU C.  No promises, but if I have time I'll give it a shot.
\par 
\par \tab In the meantime, I hope you enjoy using AVRIL.
\par }}